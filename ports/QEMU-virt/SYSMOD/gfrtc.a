    nam gfrtc.a
    ttl goldfish realtime clock driver
 
edition equ 1

    psect rtclock,(Sbrtn<<8)+Objct,((ReEnt+SupStat)<<8),edition,0,RTCTable
    use defsfile

** registers

_TIME_LOW        equ $00
_TIME_HIGH       equ $04
_ALARM_LOW       equ $08
_ALARM_HIGH      equ $0c
_IRQ_ENABLED     equ $10
_CLEAR_ALARM     equ $14
_ALARM_STATUS    equ $18
_CLEAR_INTERRUPT equ $1c

** Dispatch table
*
* Called as subroutine by the generic tick code; entry at 0 offset for GetTime,
* 4 offset for SetTime.
*
RTCTable:
    bra.w GetTime

* Defend against the preceding branch instruction being shortened to 2B by 
* assembler or linker optimisation.
    nop

** SetTime
*
* Store a new time/date in the RTC.
*
* For now, we just ignore this.
*
* Input:
*   (d0)        00hhmmss - hh, mm, ss are byte values, not BCD
*   (d1)        yyyymmdd - yyyy, mm, dd are byte values, not BCD
*   (a3)        ticker base address (not used)
*
* Output:
*   (cc)        carry clear on success
*
SetTime:
    andi        #NoCarry,ccr                    * success
    rts

** GetTime
*
* Fetch the current time and date from the RTC.
*
* The Goldfish RTC does not support calendar time, so we just return a
* default value.
*
* Input:
*   (a3)        ticker base address (not used)
*   (a4)        current process descriptor
*   (a5)        caller's register context
*   (a6)        system globals
*
* Output:
*   (d0)        00hhmmss - hh, mm, ss are byte values, not BCD
*   (d1)        yyyymmdd - yyyy, mm, dd are byte values, not BCD
*   (cc)        carry clear on success, set on error
*
GetTime:
    move.l      #$07e60101,d1                   * hardcoded date
    clr.l       d0                              * midnight, success
    rts

    endsect
